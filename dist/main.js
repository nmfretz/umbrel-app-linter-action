import e from"@actions/core";import t from"@actions/github";import{lintUmbrelAppStoreYml as n,lintDockerComposeYml as s,lintUmbrelAppYml as r}from"umbrel-cli/dist/lib.js";const a=["umbrel-app.yml","docker-compose.yml","umbrel-app-store.yml"];try{const o=e.getInput("github-token",{required:!0}),i=t.getOctokit(o),l=t.context;let u=e.getInput("base"),c=e.getInput("head-sha");if(l.payload.pull_request?(e.debug("Event is a pull request"),u=u||l.payload.pull_request.base.sha,c=c||l.payload.pull_request.head.sha):e.debug("Event is not a pull request"),!u||!c)throw new Error("This action can only be run on pull requests or with the 'base' and 'head-sha' set");const p=await i.rest.repos.compareCommitsWithBasehead({owner:l.repo.owner,repo:l.repo.repo,basehead:`${u}...${c}`});if(200!==p.status)throw new Error(`Failed to compare commits: ${p.status}`);const m=p.data.files??[],f=[];for(const e of m){if(!a.some((t=>e.filename.includes(t))))continue;if("removed"===e.status)continue;const t=await i.rest.repos.getContent({owner:l.repo.owner,repo:l.repo.repo,path:e.filename,ref:c});if(!("content"in t.data))continue;const o=Buffer.from(t.data.content,"base64").toString("utf-8");switch(!0){case e.filename.endsWith("umbrel-app.yml"):{const t=await r(o);t.length>0&&f.push({filename:e.filename,result:t});break}case e.filename.endsWith("docker-compose.yml"):{const t=await s(o);t.length>0&&f.push({filename:e.filename,result:t});break}case e.filename.endsWith("umbrel-app-store.yml"):{const t=await n(o);t.length>0&&f.push({filename:e.filename,result:t});break}}}const d=f.flatMap((e=>e.result)).filter((e=>"error"===e.severity)).length,b=f.flatMap((e=>e.result)).filter((e=>"warning"===e.severity)).length,h=f.flatMap((e=>e.result)).filter((e=>"info"===e.severity)).length;let g="";switch(!0){case 0===d&&0===b:g="üéâ No errors found";break;case d>0&&b>0:g=`‚ùå ${d} errors and ${b} warnings found`;break;case d>0:g=`‚ùå ${d} errors found`;break;case b>0:g=`‚ö†Ô∏è ${b} warnings found`}for(const t of f)for(const n of t.result){if(void 0===n.line)continue;const s={title:n.title,file:t.filename,startLine:n.line.start,endLine:n.line.end,startColumn:n.column?.start,endColumn:n.column?.end};switch(n.severity){case"error":e.error(n.message,s);break;case"warning":e.warning(n.message,s);break;case"info":e.notice(n.message,s)}}e.summary.addHeading(g),e.summary.addRaw("### Legend\n\n‚ùå **Error**  \nThis must be resolved before this PR can be merged.\n\n\n‚ö†Ô∏è **Warning**  \nThis is highly encouraged to be resolved, but is not strictly mandatory.\n\n\n‚ÑπÔ∏è **Info**  \nThis is just for your information.");for(const t of f)for(const n of t.result)e.summary.addDetails(n.title,`${"error"===n.severity?"‚ùå":"warning"===n.severity?"‚ö†Ô∏è":"‚ÑπÔ∏è"} \`${n.id}\` **${n.title}**  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${n.message.replaceAll("\n","\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;")}`);e.setOutput("errors",d),e.setOutput("warnings",b),e.setOutput("infos",h),e.setOutput("results",JSON.stringify(f))}catch(t){e.setFailed(`Action failed with error ${t}`)}
